# ==============================================================================
# SCRIPT: Common-Functions.ps1
# PURPOSE: Provides common functions for all CCDC Windows defense scripts
# USAGE: . .\common\Common-Functions.ps1
# ==============================================================================

# ------------------------------------------------------------------------------
# 1. CONSOLE OUTPUT FUNCTIONS
# ------------------------------------------------------------------------------

function Write-Header {
    param([string]$Title)
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host ""
    Write-Host "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" -ForegroundColor Blue
    Write-Host "[$timestamp] $Title" -ForegroundColor Cyan
    Write-Host "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" -ForegroundColor Blue
}

function Write-Info {
    param([string]$Message)
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host "[$timestamp] " -NoNewline -ForegroundColor White
    Write-Host "[*] " -NoNewline -ForegroundColor Cyan
    Write-Host $Message
}

function Write-Success {
    param([string]$Message)
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host "[$timestamp] " -NoNewline -ForegroundColor White
    Write-Host "[OK] " -NoNewline -ForegroundColor Green
    Write-Host $Message -ForegroundColor Green
}

function Write-Warning {
    param([string]$Message)
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host "[$timestamp] " -NoNewline -ForegroundColor White
    Write-Host "[!] " -NoNewline -ForegroundColor Yellow
    Write-Host $Message -ForegroundColor Yellow
}

function Write-Error {
    param([string]$Message)
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host "[$timestamp] " -NoNewline -ForegroundColor White
    Write-Host "[ERROR] " -NoNewline -ForegroundColor Red
    Write-Host $Message -ForegroundColor Red
}

function Write-SubHeader {
    param([string]$Title)
    $timestamp = Get-Date -Format "HH:mm:ss"
    Write-Host ""
    Write-Host "[$timestamp] [$Title]" -ForegroundColor White
}

# ------------------------------------------------------------------------------
# 2. ADMIN CHECK
# ------------------------------------------------------------------------------

function Test-Administrator {
    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

function Require-Administrator {
    if (-not (Test-Administrator)) {
        Write-Error "This script must be run as Administrator!"
        Write-Host "Right-click PowerShell and select 'Run as Administrator'" -ForegroundColor Yellow
        exit 1
    }
}

# ------------------------------------------------------------------------------
# 3. SPLUNK LOG FORWARDING (Windows Event Forwarding via WinRM to Syslog)
# ------------------------------------------------------------------------------

function Setup-SplunkForwarding {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SplunkServerIP,
        
        [Parameter(Mandatory=$false)]
        [int]$SplunkPort = 514,
        
        [Parameter(Mandatory=$false)]
        [switch]$DryRun
    )
    
    Write-SubHeader "Splunk Log Forwarding Configuration"
    
    if ([string]::IsNullOrEmpty($SplunkServerIP) -or $SplunkServerIP -eq "127.0.0.1") {
        Write-Warning "SPLUNK_SERVER_IP not set. Skipping log forwarding setup."
        return
    }
    
    Write-Info "Target Splunk Server: ${SplunkServerIP}:${SplunkPort}"
    
    # Install NXLog for Windows Syslog forwarding
    $nxlogPath = "C:\Program Files\nxlog"
    $nxlogConfig = "C:\Program Files\nxlog\conf\nxlog.conf"
    
    if (-not (Test-Path $nxlogPath)) {
        Write-Warning "NXLog not installed. Will configure Windows Event Forwarding instead."
        
        # Alternative: Configure Windows Event Collector (WEC) / WEF
        Setup-WindowsEventForwarding -SplunkServerIP $SplunkServerIP -DryRun:$DryRun
        return
    }
    
    # Configure NXLog to forward to Splunk
    $nxlogConf = @"
## NXLog configuration for CCDC Splunk Forwarding
## Generated by CCDC Defense Toolkit

define ROOT C:\Program Files\nxlog
define CERTDIR %ROOT%\cert
define CONFDIR %ROOT%\conf
define LOGDIR %ROOT%\data
define LOGFILE %LOGDIR%\nxlog.log

Moduledir %ROOT%\modules
CacheDir %ROOT%\data
Pidfile %ROOT%\data\nxlog.pid
SpoolDir %ROOT%\data

<Extension syslog>
    Module      xm_syslog
</Extension>

<Input eventlog>
    Module      im_msvistalog
    Query       <QueryList>\
                    <Query Id="0">\
                        <Select Path="Security">*</Select>\
                        <Select Path="System">*</Select>\
                        <Select Path="Application">*</Select>\
                    </Query>\
                </QueryList>
</Input>

<Output splunk>
    Module      om_udp
    Host        $SplunkServerIP
    Port        $SplunkPort
    Exec        to_syslog_bsd();
</Output>

<Route 1>
    Path        eventlog => splunk
</Route>
"@
    
    if ($DryRun) {
        Write-Info "[DRY-RUN] Would create NXLog config at: $nxlogConfig"
        Write-Info "[DRY-RUN] Config content:"
        Write-Host $nxlogConf -ForegroundColor Gray
    } else {
        try {
            $nxlogConf | Out-File -FilePath $nxlogConfig -Encoding UTF8 -Force
            Write-Success "NXLog configuration created."
            
            # Restart NXLog service
            Restart-Service -Name nxlog -ErrorAction SilentlyContinue
            Write-Success "NXLog service restarted. Logs are now being shipped!"
        } catch {
            Write-Error "Failed to configure NXLog: $_"
        }
    }
}

function Setup-WindowsEventForwarding {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SplunkServerIP,
        
        [Parameter(Mandatory=$false)]
        [switch]$DryRun
    )
    
    Write-Info "Configuring Windows Event Forwarding..."
    
    # Enable WinRM
    if (-not $DryRun) {
        try {
            # Enable WinRM service
            Set-Service -Name WinRM -StartupType Automatic
            Start-Service -Name WinRM -ErrorAction SilentlyContinue
            
            # Configure WinRM
            winrm quickconfig -quiet 2>$null
            
            # Enable Windows Remote Management firewall rules
            Enable-PSRemoting -Force -SkipNetworkProfileCheck 2>$null
            
            Write-Success "Windows Event Forwarding enabled."
            Write-Info "Note: Configure Splunk Universal Forwarder for best results."
            Write-Info "Download from: https://www.splunk.com/en_us/download/universal-forwarder.html"
        } catch {
            Write-Error "Failed to configure WEF: $_"
        }
    } else {
        Write-Info "[DRY-RUN] Would enable WinRM and Windows Event Forwarding"
    }
}

# ------------------------------------------------------------------------------
# 4. FIREWALL HELPERS
# ------------------------------------------------------------------------------

function Add-FirewallRule {
    param(
        [Parameter(Mandatory=$true)]
        [string]$DisplayName,
        
        [Parameter(Mandatory=$true)]
        [string]$Direction,  # Inbound or Outbound
        
        [Parameter(Mandatory=$true)]
        [string]$Action,     # Allow or Block
        
        [Parameter(Mandatory=$false)]
        [string]$Protocol = "TCP",
        
        [Parameter(Mandatory=$false)]
        [int[]]$LocalPort,
        
        [Parameter(Mandatory=$false)]
        [string[]]$RemoteAddress,
        
        [Parameter(Mandatory=$false)]
        [switch]$DryRun
    )
    
    if ($DryRun) {
        Write-Info "[DRY-RUN] Would add firewall rule: $DisplayName ($Direction, $Action, Port: $LocalPort)"
        return
    }
    
    try {
        $params = @{
            DisplayName = $DisplayName
            Direction   = $Direction
            Action      = $Action
            Protocol    = $Protocol
            Enabled     = $true
        }
        
        if ($LocalPort) { $params.LocalPort = $LocalPort }
        if ($RemoteAddress) { $params.RemoteAddress = $RemoteAddress }
        
        # Remove existing rule if exists
        Remove-NetFirewallRule -DisplayName $DisplayName -ErrorAction SilentlyContinue
        
        New-NetFirewallRule @params | Out-Null
        Write-Success "Firewall rule added: $DisplayName"
    } catch {
        Write-Error "Failed to add firewall rule: $_"
    }
}

function Backup-FirewallRules {
    param(
        [Parameter(Mandatory=$false)]
        [string]$BackupPath = "C:\CCDC\Backups\Firewall"
    )
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $backupFile = Join-Path $BackupPath "firewall_backup_$timestamp.wfw"
    
    if (-not (Test-Path $BackupPath)) {
        New-Item -ItemType Directory -Path $BackupPath -Force | Out-Null
    }
    
    try {
        netsh advfirewall export $backupFile | Out-Null
        Write-Success "Firewall rules backed up to: $backupFile"
        return $backupFile
    } catch {
        Write-Error "Failed to backup firewall rules: $_"
        return $null
    }
}

function Restore-FirewallRules {
    param(
        [Parameter(Mandatory=$true)]
        [string]$BackupFile
    )
    
    if (-not (Test-Path $BackupFile)) {
        Write-Error "Backup file not found: $BackupFile"
        return $false
    }
    
    try {
        netsh advfirewall import $BackupFile | Out-Null
        Write-Success "Firewall rules restored from: $BackupFile"
        return $true
    } catch {
        Write-Error "Failed to restore firewall rules: $_"
        return $false
    }
}

# ------------------------------------------------------------------------------
# 5. SERVICE MANAGEMENT
# ------------------------------------------------------------------------------

function Disable-DangerousServices {
    param(
        [Parameter(Mandatory=$false)]
        [string[]]$Services = @(
            "RemoteRegistry",
            "Telnet",
            "TlntSvr",
            "SNMP",
            "SNMPTRAP",
            "SSDPSRV",
            "upnphost",
            "WMPNetworkSvc",
            "Browser",
            "lmhosts",
            "Messenger",
            "NetTcpPortSharing"
        ),
        
        [Parameter(Mandatory=$false)]
        [switch]$DryRun
    )
    
    Write-SubHeader "Disabling Dangerous Services"
    
    foreach ($svc in $Services) {
        $service = Get-Service -Name $svc -ErrorAction SilentlyContinue
        if ($service) {
            if ($DryRun) {
                Write-Info "[DRY-RUN] Would disable service: $svc"
            } else {
                try {
                    Stop-Service -Name $svc -Force -ErrorAction SilentlyContinue
                    Set-Service -Name $svc -StartupType Disabled
                    Write-Success "Disabled service: $svc"
                } catch {
                    Write-Warning "Could not disable service: $svc - $_"
                }
            }
        }
    }
}

# ------------------------------------------------------------------------------
# 6. USER MANAGEMENT
# ------------------------------------------------------------------------------

function Get-LocalAdmins {
    try {
        $admins = Get-LocalGroupMember -Group "Administrators" -ErrorAction Stop
        return $admins
    } catch {
        # Fallback for older Windows versions
        $admins = net localgroup Administrators | Where-Object { $_ -match '\S' } | 
                  Select-Object -Skip 4 | Select-Object -SkipLast 1
        return $admins
    }
}

function Set-StrongPasswordPolicy {
    param(
        [Parameter(Mandatory=$false)]
        [switch]$DryRun
    )
    
    Write-SubHeader "Configuring Strong Password Policy"
    
    $secpol = @"
[Unicode]
Unicode=yes
[System Access]
MinimumPasswordAge = 1
MaximumPasswordAge = 90
MinimumPasswordLength = 12
PasswordComplexity = 1
PasswordHistorySize = 24
LockoutBadCount = 5
ResetLockoutCount = 30
LockoutDuration = 30
"@
    
    if ($DryRun) {
        Write-Info "[DRY-RUN] Would apply strong password policy"
        return
    }
    
    try {
        $tempFile = [System.IO.Path]::GetTempFileName()
        $secpol | Out-File -FilePath $tempFile -Encoding Unicode
        secedit /configure /db secedit.sdb /cfg $tempFile /areas SECURITYPOLICY /quiet
        Remove-Item $tempFile -Force
        Write-Success "Strong password policy applied."
    } catch {
        Write-Error "Failed to apply password policy: $_"
    }
}

# ------------------------------------------------------------------------------
# 7. AUDIT POLICY
# ------------------------------------------------------------------------------

function Enable-AuditPolicy {
    param(
        [Parameter(Mandatory=$false)]
        [switch]$DryRun
    )
    
    Write-SubHeader "Enabling Comprehensive Audit Policy"
    
    $auditCategories = @(
        "Account Logon",
        "Account Management",
        "DS Access",
        "Logon/Logoff",
        "Object Access",
        "Policy Change",
        "Privilege Use",
        "System"
    )
    
    foreach ($category in $auditCategories) {
        if ($DryRun) {
            Write-Info "[DRY-RUN] Would enable audit for: $category"
        } else {
            try {
                auditpol /set /category:"$category" /success:enable /failure:enable 2>$null
                Write-Success "Enabled audit for: $category"
            } catch {
                Write-Warning "Could not enable audit for: $category"
            }
        }
    }
}

# ------------------------------------------------------------------------------
# 8. BANNER
# ------------------------------------------------------------------------------

function Show-CCDCBanner {
    param(
        [string]$Version = "2.0",
        [string]$MachineName = "Windows"
    )
    
    $mode = if ($script:DryRun) { "DRY-RUN" } else { "LIVE" }
    
    Write-Host ""
    Write-Host "╔══════════════════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "║           CCDC DEFENSE TOOLKIT v$Version - Windows              ║" -ForegroundColor Cyan
    Write-Host "╠══════════════════════════════════════════════════════════════╣" -ForegroundColor Cyan
    Write-Host "║  Machine: $($MachineName.PadRight(48))║" -ForegroundColor Cyan
    Write-Host "║  Mode: $($mode.PadRight(51))║" -ForegroundColor Cyan
    Write-Host "╚══════════════════════════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""
}
